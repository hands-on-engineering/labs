# RFID Lab 1: SPI 
## Goal
The goal of this video is to introduce what Serial Peripheral Interface
(SPI) is to students. We will compare it to I2C and UART to give students
a comprehensive understanding of interface communications.

## Content Organization
### Overview

- Asynchronous vs synchronous
- Useful for high speed transfer over short distances
- Occasionally SPI will be our only option if the sensor doesn't support I2C or UART
- There is no formal standard, so we need to be familiar with reading the datasheet to determine how to send data messages correctly

### Interface
- MISO, MOSI, SCK, SS
- Multiple slaves: individual SS lines or daisy chaining
- SPI Mode: polarity and clock phase
- Timing
    * SS low 
    * SCK indicates sampling
    * Data sent over MISO and MOSI
    * SS goes high again

#### Arduino SPI capabilities
- The Arduino uses AVR chips that provide dedicated SPI communication
hardware, with certain pins dedicated to be MOSI/MISO/SCK/SS
    * An ICSP header can be used to standardize which pins these are for
    most boards; they are usually tied to certain digital pins
    * On an Arduino Nano, the ICSP header is tied to the following pins:
        - 10 (SS), 11 (MOSI), 12 (MISO), 13 (SCK)
        - Pin 13 is also tied to the built in LED
- Can use other pins with bit banging, but we won't cover this

### Comparison to other Serial communication protocols
|      | Pins Needed | Speeds                                                   | Distance |
|------|-------------|----------------------------------------------------------|----------|
| UART | 2           | 115.2 kbps                                               | 10+ m    |
| SPI  | 4           | 4 Mbps as slave, 8 Mbps as master                        | ~0.25 m  |
| I2C  | 2           | Typically 0.4 Mbps, some processors can support 3.4 Mbps | ~1 m     |

## Transcript

Hello and welcome to another Hands on engineering video. In this video
we'll discuss the SPI protocol and demonstrate reading registers from a
typical SPI based sensor.

SPI stands for Serial Peripheral Interface. It is a synchronous serial
communication interface, which just means that we use a clock to
standardize commiunication and send bits out one after another. SPI is most
useful for very high speed transfers over short distances. 

Let's compare it to some of the other Serial communication protocols that
we've covered. *SHOW TABLE OF COMPARISONS*. We can see that SPI needs more
wires and operates at much smaller distances, but also provides extremely
fast data transfer. I2C and UART both only require 2 wires, and the
trade-off between the two is speed versus distance. UART is preferred for
larger distances where speed can be disregarded, and I2C is where speed is
required over a smaller distance. 

SPI doesn't have a formal standard to describe how data should be encoded
over the lines, so we typically need to resort to reading datasheets for
the sensors we are interfacing with. That said, there is a typical way to
read and write to sensor registers over SPI, and that is what our example
later will cover.

We will have 1 master, like our Arduino microcontroller, communicating with
many slavesâ€”the sensors.

Onto the interface itself, typical SPI devices communicate over 4 lines.
These lines are Master In Slave Out (MISO), Master Out Slave In (MOSI),
SCLK (Serial Clock), and Slave Select (SS). The clock is generated by the
master and serves to synchronize everyone communicating over the bus.
*SHOW DIAGRAM OF 4 LINES*

At a high level, the master draws the SS line low for the slave it wants to
communicate with. Then, data is sent over the MOSI line towards the slave.
If the slave has something to respond with, then this data will be sent
over the MISO line. When communication with the slave is over, the master
will pull the SS line high, releasing the slave.  *SHOW DIAGRAM OF
COMMUNICATION EXAMPLE*

The specifics of when data is sampled over the lines depends on what SPI
mode we're using. SPI modes are made up of combinations controlling the
clock polarity (CPOL) and clock phase (CPHA). What this means is that we
need to choose which whether the clock idles/starts low or high, and
whether data is sampled on the falling or rising edge of the clock.  Since
we have 2 settings with 2 options each, we have a total of 4 SPI modes.
*SHOW TABLE OF MODES*.

The reason we have all these modes is because, as mentioned before, there
is no standard for SPI and so we have to be willing to adapt to master/
slave requirements.

Now let's go over an example. Here I have an RFID sensor called an MFRC522.
The device only supports SPI communication, and as mentioned before it uses
the most typical SPI reading/writing formats.

The Arduino uses an AVR microchip that provides dedicated SPI communication
hardware, with certain pins dedicated to be MOSI, MISO, SCK, and SS. Since
these pins vary in location by board model, they are also tied to an ICSP
header which are on the 2x3 grid of pins at the edge of boards. 

On the Nano model which we will be using, pin 10 is SS, pin 11 is MOSI, pin
12 is MISO, and pin 13 is SCK.  I've wired up these pins to the
corresponding pins on the sensor.  Pin 13 also happens to be tied into the
built in LED, and some sensors operating at high speeds may have issues
because of this.  There are some mentioned online that removing the LED may
help in these cases.

*SHOW CODE* There is a register in this sensor called the VersionReg, which
returns the firmware version on the sensor. What is on the screen now is
the code to read this register.

Firstly I define a variable for the version register's hexadecimal address.
Then I define a constant for the SPI settings. The datasheet describes how
it wants us to sample relative to the clock, and using this we know to use
either mode 0 or mode 3. The datasheet also specifies that we should send
data most significant bit first over the lines.

In the setup, we call this method `readRegister` which returns a byte of
data and takes in a byte address for the register. Going down to the
method, we see that first we tell the SPI library to get ready for a
transaction. Then we see some corrections that need to be done to the
address specific to this sensor. In the datasheet, it says that the LSB is
always 0 and the MSB determines whether we are reading or writing.  I want
to stress that this is specific to the MFRC522, and I am only showing this
because I want to emphasize the importance of reading the datasheet for the
sensor you are using carefully.

Next we pull the SS line low, which will tell the sensor to get ready.  The
datasheet also describes which order bytes are meant to be sent and
received. *SHOW TABLE 6*. We see that the sensor wants us to send our
address out of the master at byte 0 and ignore what comes in from the
slave. Then, we can grab the data on the next byte. We can also end reading
by sending out `0x00`.

Finally, we draw the SS line high and end the SPI transaction.

When we run this code, we see the hex value `0x92`. If we look at the
datasheet for this sensor, we'll see that the first value is the chiptype
and the second value is the firmware version. So, we have successfully read
the version register.

That's all we have for you today. Hopefully you've learned something about
SPI. We hope you enjoyed the video, please leave a comment if you have any
questions and we'll try to get back to you.
